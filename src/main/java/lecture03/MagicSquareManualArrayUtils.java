package lecture03;

import org.chocosolver.solver.Model;
import org.chocosolver.solver.Solver;
import org.chocosolver.solver.variables.IntVar;

/*
 * A general version of the magic Square problem
 *   - now we allow the square to be any size
 *   - which means we must compute the value of the row sum as input to the problem
 *   - and we use a matrix (or 2D array) of variables
 *   Here, I have hard-coded the square size as the value of n
 *   You could, of course, instead read this in from the command line
 */
public class MagicSquareManualArrayUtils {

   public static void main(String[] args) {

      // Create a Model
      Model model = new Model("Magic Square General");


      // Create variables
      int n = 3;   //n is the length of the side of the square
      int T = n*(n*n + 1)/2;    //T is the sum for the rows, columns and diagonals
      System.out.println("Square length = " + n + "; Target = " + T);

      //create a 2D array of IntVars for the square
      IntVar[][] square = model.intVarMatrix("square",  n,  n,  1,  n*n);

      //create an IntVar for the target, since it is required for the sum constraint
      IntVar target = model.intVar("target", T);

      //now create references to the decision variables, in different arrays, 
      //to make it easier to write the constraints
      //This is because it is easy in Java to talk about a row of a 2D array (just use the first index)
      //but it is not easy to refer to a column
      //So we create the transpose of the matrix, and talk about its rows instead.
      //We create special arrays for the diagonal cells.
      //Note: none of these are creating new CSP variables, just new references to the original vars
      IntVar[] flatVars = new IntVar[n*n];
      IntVar[][] transpose = new IntVar[n][n];
      IntVar[] diagdown = new IntVar[n];
      IntVar[] diagup = new IntVar[n];

      for (int row = 0; row<n; row++) {
         for (int col = 0; col<n; col++) {
            flatVars[(n*row)+col] = square[row][col];
            transpose[col][row] = square[row][col];
         }
         diagdown[row] = square[row][row];
         diagup[row] = square[(n-1)-row][row];
      }

      //now post the constraints on the rows, columns and diagonals
      for (int row = 0; row<n; row++) {
         model.sum(square[row], "=", target).post();
         model.sum(transpose[row], "=", target).post();
      }
      model.sum(diagdown, "=", target).post();
      model.sum(diagup, "=", target).post();


      //now make sure that all values are different
      model.allDifferent(flatVars).post();

      //breaking symmetries, to reduce search
      /*
      model.arithm(square[0][0], "<", square[n-1][n-1]).post();
      model.arithm(square[0][0], "<", square[0][n-1]).post();
      model.arithm(square[0][0], "<", square[n-1][0]).post();
      
      model.arithm(square[0][n-1], "<", square[n-1][0]).post();
      */

      // Solve the problem
      Solver solver = model.getSolver();

      //varying search strategy to speed things up

      //solver.setSearch(Search.domOverWDegSearch(flatVars));
      //solver.setSearch(Search.inputOrderLBSearch(flatVars));
      //solver.setSearch(Search.activityBasedSearch(flatVars)); 		 
      //solver.setSearch(new ImpactBased(flatVars, 2,3,10, 0, false));

      //Note: the Search class provides some ready-packaged strategies, generated by helper methods.
      //You can also define your own search strategy, and we will see later in the module what this would involve.
      //The Impacts strategy is defined as a class in the source code, but is not offered as a pre-packaged helper method
      //(I am not sure why)

      //if (solver.solve()) {
      while (solver.solve()) { //print the solution
         System.out.println("Solution " + solver.getSolutionCount() + ":");
         for (int row = 0; row < n; row++) {
            for (int col = 0; col < n; col++) {
               System.out.print(square[row][col] + " ");
            }
            System.out.println();
         }
         System.out.println();
      }
      System.out.println("No more solutions");

      // else {
      // System.out.println("NO SOLUTION");
      //}
      //MeasuresRecorder measures = solver.getMeasures();
      //float bTime = measures.getReadingTimeCount();
      //System.out.printf("Building time is %s\n", bTime);
      //System.out.printf("%s\n", measures.toString());
      solver.printStatistics();
      //solver.printStatistics();
      //measures = solver.getMeasures();
      //bTime = measures.getReadingTimeCount();
      //System.out.printf("Building time is %s\n", bTime);
      //System.out.printf("%s\n", measures.toString());
   }

}
