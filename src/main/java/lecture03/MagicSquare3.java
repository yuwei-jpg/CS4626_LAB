package lecture03;

import org.chocosolver.solver.Model;
import org.chocosolver.solver.Solver;
import org.chocosolver.solver.search.strategy.selectors.variables.ImpactBased;
import org.chocosolver.solver.variables.IntVar;
import org.chocosolver.util.tools.ArrayUtils;

/*
 * A general version of the Magic Square problem as a matrix
 *   - now we allow the square to be any size
 *   - which means we must compute the value of the row sum as input to the problem
 *   Here, I have hard-coded the square size as the value of n
 *   You could, of course, read this in from the command line instead
 */
public class MagicSquare3 {

   public static void main(String[] args) {

      // Create a Model
      Model model = new Model("Magic Square General");


      // Create variables
      int n=10;   //n is the length of the side of the square
      int T = n*(n*n + 1)/2;    //T is the sum for each row, column or diagonal
      //To get the target, add up all the possible values (ie sum of everything in the grid)
      //That is the same as summing each row, and then adding all the rowsums together.
      //All rows must have the same sum, 
      //so each row must sum to the total of all squares, divided by the number of rows (n)
      //Note - standard formula for summing all integers from 1 up to k is 0.5*k*(k+1)
      //We are summing up to n*n, so we get 0.5*(n*n)*(n*n + 1)
      //and dividing that by n gives 0.5*n*(n*n+1)
      System.out.println("Square length = " + n + "; Target = " + T);

      //create a 2D array of IntVars for the square
      IntVar[][] square = model.intVarMatrix("square",  n,  n,  1,  n*n);

      //create an IntVar for the target, since it is required for the sum constraint
      IntVar target = model.intVar("target", T);

      //now create references to arrays of the decision variables
      IntVar[] flatVars = ArrayUtils.flatten(square);

      IntVar[] diagdown = new IntVar[n];
      IntVar[] diagup = new IntVar[n];
      for (int row = 0; row<n; row++) {
         diagdown[row] = square[row][row];
         diagup[row] = square[(n-1)-row][row];
      }

      //now post the constraints on the rows, columns and diagonals
      for (int row = 0; row<n; row++) {
         model.sum(square[row], "=", target).post();
         model.sum(ArrayUtils.getColumn(square,row), "=", target).post();
      }
      model.sum(diagdown, "=", target).post();
      model.sum(diagup, "=", target).post();


      //now make sure that all values are different
      model.allDifferent(flatVars).post();

      //breaking symmetries, to reduce search
      /* */
      model.arithm(square[0][0], "<", square[n-1][n-1]).post();
      model.arithm(square[0][0], "<", square[0][n-1]).post();
      model.arithm(square[0][0], "<", square[n-1][0]).post();
      
      model.arithm(square[0][n-1], "<", square[n-1][0]).post();
      /* */

      // Solve the problem
      Solver solver = model.getSolver();

      //varying search strategy to speed things up

      //solver.setSearch(Search.domOverWDegSearch(flatVars));
      //solver.setSearch(Search.inputOrderLBSearch(flatVars));
      //solver.setSearch(Search.activityBasedSearch(flatVars)); 		//Do not search for all solutions to a CSP using activityBased -- see below 
      solver.setSearch(new ImpactBased(flatVars, 2,3,10, 0, false));
      
      //Note: the Search class provides some ready-packaged strategies, generated by helper methods.
      //You can also define your own search strategy, and we will see later in the module what this would involve.
      //The Impacts strategy is defined as a class in the source code, but is not offered as a pre-packaged helper method
      //(I don't know why)

      //ActivityBasedSearch restarts after each solution, and so will discover again solutions it has already reported
      //Either impose a limit on the number of solutions, or on the time
      //Maximising or minimising works OK, since solutions must improve each iteration.
      //Searching for a single solution works OK.


      if(solver.solve()) {
      //while (solver.solve()) { //print the solution
         System.out.println("Solution " + solver.getSolutionCount() + ":");
         
         for (int row = 0; row < n; row++) {
            for (int col = 0; col < n; col++) {
               System.out.print(square[row][col] + " ");
            }
            System.out.println();
         }
         System.out.println();
         
      }
      //System.out.println(count + " solutions.");
      //System.out.println("No more solutions.");

      else {
         System.out.println("NO SOLUTION");
      }
      //MeasuresRecorder measures = solver.getMeasures();
      //float rTime = measures.getTimeCount();
      //System.out.printf("time since start: %s\n", rTime);
      //float bTime = measures.getReadingTimeCount();
      //System.out.printf("Building time is %s\n", bTime);
      //System.out.printf("%s\n", measures.toString());
      solver.printStatistics();
      //measures = solver.getMeasures();
      //bTime = measures.getReadingTimeCount();
      //System.out.printf("Building time is %s\n", bTime);
      //System.out.printf("%s\n", measures.toString());
   }

}
